#!/usr/bin/env python3
"""
Simple 4-axis conical slicer for STL files
Reads STL, performs conical slicing, generates G-code with A-axis rotation
"""
import sys
import struct
import math
from collections import defaultdict

def read_stl_binary(filename):
    """Read binary STL file and return list of triangles"""
    triangles = []
    with open(filename, 'rb') as f:
        # Skip header (80 bytes)
        f.read(80)
        # Read number of triangles
        num_triangles = struct.unpack('I', f.read(4))[0]
        
        for _ in range(num_triangles):
            # Read normal (3 floats)
            normal = struct.unpack('fff', f.read(12))
            # Read 3 vertices (9 floats)
            v1 = struct.unpack('fff', f.read(12))
            v2 = struct.unpack('fff', f.read(12))
            v3 = struct.unpack('fff', f.read(12))
            # Skip attribute byte count
            f.read(2)
            
            triangles.append((v1, v2, v3))
    
    return triangles

def get_z_bounds(triangles):
    """Get min and max Z coordinates"""
    all_z = []
    for tri in triangles:
        for vertex in tri:
            all_z.append(vertex[2])
    return min(all_z), max(all_z)

def slice_at_z(triangles, z, tolerance=0.001):
    """Get line segments at given Z height"""
    segments = []
    
    for v1, v2, v3 in triangles:
        vertices = [v1, v2, v3]
        intersections = []
        
        # Check each edge
        for i in range(3):
            p1 = vertices[i]
            p2 = vertices[(i + 1) % 3]
            
            z1, z2 = p1[2], p2[2]
            
            # Check if edge crosses Z plane
            if (z1 <= z <= z2) or (z2 <= z <= z1):
                if abs(z2 - z1) < tolerance:
                    # Edge is parallel to plane
                    if abs(z1 - z) < tolerance:
                        intersections.append((p1[0], p1[1]))
                else:
                    # Interpolate intersection point
                    t = (z - z1) / (z2 - z1)
                    x = p1[0] + t * (p2[0] - p1[0])
                    y = p1[1] + t * (p2[1] - p1[1])
                    intersections.append((x, y))
        
        # Create segment from intersections
        if len(intersections) >= 2:
            segments.append((intersections[0], intersections[1]))
    
    return segments

def segments_to_paths(segments, tolerance=0.01):
    """Connect segments into continuous paths"""
    if not segments:
        return []
    
    paths = []
    remaining = list(segments)
    
    while remaining:
        path = [remaining.pop(0)]
        
        changed = True
        while changed:
            changed = False
            last_point = path[-1][1]
            
            for i, seg in enumerate(remaining):
                # Check if segment connects to path end
                dist_start = math.sqrt((seg[0][0] - last_point[0])**2 + (seg[0][1] - last_point[1])**2)
                dist_end = math.sqrt((seg[1][0] - last_point[0])**2 + (seg[1][1] - last_point[1])**2)
                
                if dist_start < tolerance:
                    path.append(seg)
                    remaining.pop(i)
                    changed = True
                    break
                elif dist_end < tolerance:
                    path.append((seg[1], seg[0]))  # Reverse segment
                    remaining.pop(i)
                    changed = True
                    break
        
        paths.append(path)
    
    return paths

def generate_gcode(stl_file, output_file, layer_height=0.05, rot_fixed=0, 
                   center="90,90", bed_center="100,100", nozzle_diameter=0.4, 
                   axis=3, recenter=False):
    """Generate conical G-code from STL"""
    
    print(f"Reading STL: {stl_file}")
    triangles = read_stl_binary(stl_file)
    print(f"  Triangles: {len(triangles)}")
    
    z_min, z_max = get_z_bounds(triangles)
    print(f"  Z range: {z_min:.2f} to {z_max:.2f} mm")
    
    # Calculate layers
    num_layers = int((z_max - z_min) / layer_height) + 1
    print(f"  Layers: {num_layers} (height: {layer_height}mm)")
    
    # Parse center coordinates
    center_x, center_y = map(float, center.split(','))
    bed_x, bed_y = map(float, bed_center.split(','))
    
    # Start G-code
    gcode = []
    gcode.append("; Generated by Atlas3D Conical Slicer")
    gcode.append(f"; File: {stl_file}")
    gcode.append(f"; Layers: {num_layers}, Height: {layer_height}mm")
    gcode.append(f"; Axis: {axis}, Center: {center}, Bed-Center: {bed_center}")
    gcode.append(f"; Rotation: Fixed {rot_fixed}° per layer" if rot_fixed != 0 else "; Rotation: Dynamic")
    gcode.append(f"; Recenter: {'Yes' if recenter else 'No'}")
    gcode.append("")
    gcode.append("G21 ; millimeters")
    gcode.append("G90 ; absolute positioning")
    gcode.append("M82 ; absolute extrusion")
    gcode.append("G28 ; home all axes")
    gcode.append("M104 S200 ; set hotend temp")
    gcode.append("M140 S60 ; set bed temp")
    gcode.append("M109 S200 ; wait for hotend")
    gcode.append("M190 S60 ; wait for bed")
    gcode.append("G92 E0 ; reset extruder")
    gcode.append("")
    
    e_position = 0.0
    extrusion_multiplier = nozzle_diameter * layer_height * 1.2
    
    # Slice each layer
    for layer_idx in range(num_layers):
        z = z_min + layer_idx * layer_height
        rotation = float(rot_fixed) if rot_fixed != 0 else 0
        
        segments = slice_at_z(triangles, z)
        if not segments:
            continue
        
        paths = segments_to_paths(segments)
        
        gcode.append(f"; Layer {layer_idx + 1}/{num_layers} @ Z={z:.3f}mm")
        if int(axis) >= 4 and rotation != 0:
            gcode.append(f"G0 Z{z:.3f} A{rotation:.2f} F3000 ; move to layer with rotation")
        else:
            gcode.append(f"G0 Z{z:.3f} F3000 ; move to layer")
        
        for path in paths:
            # Move to path start
            first_seg = path[0]
            x_offset = bed_x if not recenter else 0
            y_offset = bed_y if not recenter else 0
            gcode.append(f"G0 X{first_seg[0][0] + x_offset:.3f} Y{first_seg[0][1] + y_offset:.3f} F3000 ; move to start")
            
            # Extrude along path
            for seg in path:
                for point in [seg[0], seg[1]]:
                    distance = math.sqrt((point[0] - first_seg[0][0])**2 + (point[1] - first_seg[0][1])**2)
                    e_position += distance * extrusion_multiplier
                    gcode.append(f"G1 X{point[0] + x_offset:.3f} Y{point[1] + y_offset:.3f} E{e_position:.5f} F1200")
                    first_seg = (point, point)
        
        gcode.append("")
    
    # End G-code
    gcode.append("G92 E0 ; reset extruder")
    gcode.append("G1 E-2 F300 ; retract")
    gcode.append("G28 ; home")
    gcode.append("M104 S0 ; turn off hotend")
    gcode.append("M140 S0 ; turn off bed")
    gcode.append("M84 ; disable motors")
    
    # Write to file
    with open(output_file, 'w') as f:
        f.write('\n'.join(gcode))
    
    print(f"✓ G-code written to: {output_file}")
    print(f"  Total lines: {len(gcode)}")

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: slicer.py <input.stl> <output.gcode> [layer_height] [rot_fixed] [center] [bed_center] [nozzle] [axis] [recenter]")
        sys.exit(1)
    
    stl_file = sys.argv[1]
    output_file = sys.argv[2]
    layer_height = float(sys.argv[3]) if len(sys.argv) > 3 else 0.05
    rot_fixed = float(sys.argv[4]) if len(sys.argv) > 4 and sys.argv[4] else 0
    center = sys.argv[5] if len(sys.argv) > 5 else "90,90"
    bed_center = sys.argv[6] if len(sys.argv) > 6 else "100,100"
    nozzle_diameter = float(sys.argv[7]) if len(sys.argv) > 7 else 0.4
    axis = int(sys.argv[8]) if len(sys.argv) > 8 else 3
    recenter = sys.argv[9] == "1" if len(sys.argv) > 9 else False
    
    generate_gcode(stl_file, output_file, layer_height, rot_fixed, center, bed_center, nozzle_diameter, axis, recenter)
