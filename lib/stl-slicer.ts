// STL Binary Reader and Simple Slicer for Vercel
interface Triangle {
  v1: [number, number, number];
  v2: [number, number, number];
  v3: [number, number, number];
}

interface Segment {
  start: [number, number];
  end: [number, number];
}

export function readSTLBinary(buffer: Buffer): Triangle[] {
  const triangles: Triangle[] = [];
  const numTriangles = buffer.readUInt32LE(80);
  
  let offset = 84; // Skip header (80) + count (4)
  
  for (let i = 0; i < numTriangles; i++) {
    // Skip normal (12 bytes)
    offset += 12;
    
    // Read 3 vertices
    const v1: [number, number, number] = [
      buffer.readFloatLE(offset),
      buffer.readFloatLE(offset + 4),
      buffer.readFloatLE(offset + 8)
    ];
    offset += 12;
    
    const v2: [number, number, number] = [
      buffer.readFloatLE(offset),
      buffer.readFloatLE(offset + 4),
      buffer.readFloatLE(offset + 8)
    ];
    offset += 12;
    
    const v3: [number, number, number] = [
      buffer.readFloatLE(offset),
      buffer.readFloatLE(offset + 4),
      buffer.readFloatLE(offset + 8)
    ];
    offset += 12;
    
    // Skip attribute byte count (2 bytes)
    offset += 2;
    
    triangles.push({ v1, v2, v3 });
  }
  
  return triangles;
}

export function getZBounds(triangles: Triangle[]): [number, number] {
  let minZ = Infinity;
  let maxZ = -Infinity;
  
  for (const tri of triangles) {
    for (const vertex of [tri.v1, tri.v2, tri.v3]) {
      const z = vertex[2];
      if (z < minZ) minZ = z;
      if (z > maxZ) maxZ = z;
    }
  }
  
  return [minZ, maxZ];
}

export function sliceAtZ(triangles: Triangle[], z: number): Segment[] {
  const segments: Segment[] = [];
  const tolerance = 0.001;
  
  for (const { v1, v2, v3 } of triangles) {
    const vertices = [v1, v2, v3];
    const intersections: [number, number][] = [];
    
    // Check each edge
    for (let i = 0; i < 3; i++) {
      const p1 = vertices[i];
      const p2 = vertices[(i + 1) % 3];
      
      const z1 = p1[2];
      const z2 = p2[2];
      
      // Check if edge crosses Z plane
      if ((z1 <= z && z <= z2) || (z2 <= z && z1 <= z)) {
        if (Math.abs(z2 - z1) < tolerance) {
          // Edge is parallel to plane
          if (Math.abs(z1 - z) < tolerance) {
            intersections.push([p1[0], p1[1]]);
          }
        } else {
          // Interpolate intersection point
          const t = (z - z1) / (z2 - z1);
          const x = p1[0] + t * (p2[0] - p1[0]);
          const y = p1[1] + t * (p2[1] - p1[1]);
          intersections.push([x, y]);
        }
      }
    }
    
    // Create segment from intersections
    if (intersections.length >= 2) {
      segments.push({
        start: intersections[0],
        end: intersections[1]
      });
    }
  }
  
  return segments;
}

export interface SlicerOptions {
  layerHeight: number;
  rotFixed: number;
  center: string;
  bedCenter: string;
  nozzleDiameter: number;
  axis: number;
  recenter: boolean;
}

export function generateGcode(
  stlBuffer: Buffer,
  options: SlicerOptions
): string {
  const triangles = readSTLBinary(stlBuffer);
  const [zMin, zMax] = getZBounds(triangles);
  
  const numLayers = Math.floor((zMax - zMin) / options.layerHeight) + 1;
  const [centerX, centerY] = options.center.split(',').map(Number);
  const [bedX, bedY] = options.bedCenter.split(',').map(Number);
  
  const gcode: string[] = [];
  gcode.push('; Generated by Atlas3D Conical Slicer');
  gcode.push(`; Layers: ${numLayers}, Height: ${options.layerHeight}mm`);
  gcode.push(`; Axis: ${options.axis}, Center: ${options.center}`);
  gcode.push(`; Rotation: Fixed ${options.rotFixed}Â° per layer`);
  gcode.push('');
  gcode.push('G21 ; millimeters');
  gcode.push('G90 ; absolute positioning');
  gcode.push('M82 ; absolute extrusion');
  gcode.push('G28 ; home all axes');
  gcode.push('M104 S200 ; set hotend temp');
  gcode.push('M140 S60 ; set bed temp');
  gcode.push('M109 S200 ; wait for hotend');
  gcode.push('M190 S60 ; wait for bed');
  gcode.push('G92 E0 ; reset extruder');
  gcode.push('');
  
  let ePosition = 0;
  const extrusionMultiplier = options.nozzleDiameter * options.layerHeight * 1.2;
  
  // Slice each layer
  for (let layerIdx = 0; layerIdx < numLayers; layerIdx++) {
    const z = zMin + layerIdx * options.layerHeight;
    const rotation = options.rotFixed;
    
    const segments = sliceAtZ(triangles, z);
    if (segments.length === 0) continue;
    
    gcode.push(`; Layer ${layerIdx + 1}/${numLayers} @ Z=${z.toFixed(3)}mm`);
    
    if (options.axis >= 4 && rotation !== 0) {
      gcode.push(`G0 Z${z.toFixed(3)} A${rotation.toFixed(2)} F3000 ; move to layer with rotation`);
    } else {
      gcode.push(`G0 Z${z.toFixed(3)} F3000 ; move to layer`);
    }
    
    // Extrude segments
    for (const seg of segments) {
      const xOffset = options.recenter ? 0 : bedX;
      const yOffset = options.recenter ? 0 : bedY;
      
      gcode.push(`G0 X${(seg.start[0] + xOffset).toFixed(3)} Y${(seg.start[1] + yOffset).toFixed(3)} F3000`);
      
      const distance = Math.sqrt(
        Math.pow(seg.end[0] - seg.start[0], 2) + 
        Math.pow(seg.end[1] - seg.start[1], 2)
      );
      ePosition += distance * extrusionMultiplier;
      
      gcode.push(`G1 X${(seg.end[0] + xOffset).toFixed(3)} Y${(seg.end[1] + yOffset).toFixed(3)} E${ePosition.toFixed(5)} F1200`);
    }
    
    gcode.push('');
  }
  
  // End G-code
  gcode.push('G92 E0 ; reset extruder');
  gcode.push('G1 E-2 F300 ; retract');
  gcode.push('G28 ; home');
  gcode.push('M104 S0 ; turn off hotend');
  gcode.push('M140 S0 ; turn off bed');
  gcode.push('M84 ; disable motors');
  
  return gcode.join('\n');
}
